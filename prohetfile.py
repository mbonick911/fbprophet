import matplotlib.pyplot as pltfrom fbprophet import Prophetfrom datetime import datetimeimport fbprophetfrom datetime import datetimefrom khoj.data import awsfrom khoj import *import pandas as pdimport numpy as npfrom datetime import datetime, date, timedeltaimport randomfrom statsmodels.tools.eval_measures import rmseimport warningsimport itertoolsfrom joblib import cpu_count, delayed, Parallel## this done to make sure matplotlib work with prophetpd.plotting.register_matplotlib_converters()## Data Pull df = aws.from_athena_query(query)## Data prep and data mergingdf['Month'] = pd.to_datetime(df['Month'])df['Month'] = df['Month'].dt.strftime("%Y/%m/%d")df['Month'] = pd.to_datetime(df['Month'])## change the orderdf = df.sort_values('Month', ascending=True)# Datadf = df.loc[df["Month"] <= '2020-09-01']df = df.loc[df["Month"] >= '2018-08-01']## Other KPISdf5 = pd.read_excel("/Users/matthew.bonick/Avira/2021-Forecasting - Documents/Models/Data/Export.xlsx",                    sheet_name='DACH')df5['ds'] = pd.to_datetime(df5['ds'])## Holidays### Adding Holidays release1 = pd.DataFrame({    'holiday': 'release1',    'ds': pd.to_datetime(pd.date_range(start='2020-01-01', end='2020-01-01')),    'lower_window': 0,    'upper_window': 1,})release2 = pd.DataFrame({    'holiday': 'release2',    'ds': pd.to_datetime(pd.date_range(start='2020-02-01', end='2020-02-01')),    'lower_window': 0,    'upper_window': 1,})release3 = pd.DataFrame({    'holiday': 'release3',    'ds': pd.to_datetime(pd.date_range(start='2020-03-01', end='2020-03-01')),    'lower_window': 0,    'upper_window': 1,})free_release = pd.DataFrame({    'holiday': 'release3',    'ds': pd.to_datetime(pd.date_range(start='2020-08-01', end='2020-09-01')),    'lower_window': 0,    'upper_window': 1,})holidays = pd.concat((release1, release2, release3, free_release))# Parameters and funtionsfrom sklearn.model_selection import ParameterGridparams_grid = {'seasonality_mode': ('multiplicative', 'additive'),               'changepoint_prior_scale': np.arange(0.2, 1.0, .2),  # np.arange(0.0, 1.0, .2),               'seasonality_prior_scale': [0.5, 0.1, 0.2, 0.3, 1, 2]}grid = ParameterGrid(params_grid)cnt = 0for i in grid:    cnt = cnt + 1print('Total Possible Models', cnt)all_params = [dict(zip(params_grid.keys(), v)) for v in itertools.product(*params_grid.values())]## rename for prophet and inproduct predictiondf2 = df.rename(columns={'Month': 'ds', 'Prime_orders_INPRODUCT_DACH': 'y'})## change the orderdf2 = df2.sort_values('ds', ascending=True)df2 = df2.reset_index()df2.drop(columns=['index'], inplace=True)## set cap and floor cap = (df2.max()['y']) * .6floor = df2.min()['y']df2['cap'] = capdf2['floor'] = floor## Months to predictmonths_to_predict = 3## train and test split we only have enough data for two monthstrain = df2.iloc[: len(df2) - int(months_to_predict)]test = df2.iloc[len(df2) - int(months_to_predict):]## Join train = train.merge(df5, on='ds', how="inner")## adjust so we only keep the months we need to predicttrain = train.iloc[:len(df)]test = test.merge(df5, on='ds', how="inner")## Funtiondef fb_model_eval(train, test, params):    """Trains an FB Prophet model with the training set and evaluates its performance with the test set."""    # Unpack parameter list into their components    params = params    # dependent variable    train = train    test = test    with warnings.catch_warnings():        warnings.filterwarnings("ignore")        train_model = Prophet(**params,                              interval_width=0.95,                              holidays=holidays,                              yearly_seasonality=True)        train_model.add_regressor('Acquisition Installs')        train_model.add_regressor('Affiliate Installs')        train_model.add_regressor('Organic Installs')        train_model.fit(train)        train_forecast = train_model.make_future_dataframe(periods=months_to_predict, freq='MS', include_history=False)        train_forecast['cap'] = cap        train_forecast['floor'] = floor        train_forecast['Acquisition Installs'] = test['Acquisition Installs']        train_forecast['Affiliate Installs'] = test['Affiliate Installs']        train_forecast['Organic Installs'] = test['Organic Installs']        train_predict = train_model.predict(train_forecast)        RMSE = rmse(test['y'], train_predict['yhat'])    return {'RMSE': RMSE, 'params': params}executer = Parallel(n_jobs=-2, backend='loky')tasks = (delayed(fb_model_eval)(train, test, params) for params in all_params)scores = executer(tasks)test = pd.DataFrame(scores).sort_values('RMSE')test_best = test.iloc[0]print(test)best = test_best[['params']].values[0]changepoint_prior_scale = list(best.values())[1]seasonality_mode = list(best.values())[0]seasonality_prior_scale = list(best.values())[2]## Foecast df3 = df2.merge(df5, on='ds', how='right')## days into the future we want to predicforecast_timeframe = 15print(df2.tail())train_model = Prophet(    seasonality_prior_scale=.1,    seasonality_mode='additive',    growth='logistic',    holidays=holidays,    interval_width=0.95,    yearly_seasonality=True)train_model.add_regressor('Acquisition Installs')train_model.add_regressor('Affiliate Installs')train_model.add_regressor('Organic Installs')train_model.fit(df3.iloc[:len(df3) - forecast_timeframe])future = train_model.make_future_dataframe(periods=int(forecast_timeframe), freq='MS')future['cap'] = capfuture['floor'] = floorfuture['Acquisition Installs'] = df3['Acquisition Installs']future['Affiliate Installs'] = df3['Affiliate Installs']future['Organic Installs'] = df3['Organic Installs']forecast = train_model.predict(future)## Forecast Plotfrom fbprophet.plot import add_changepoints_to_plotfig = train_model.plot(forecast)a = add_changepoints_to_plot(fig.gca(), train_model, forecast)## componentstrain_model.plot_components(forecast)## only take future valuesinproduct_future = forecast.loc[forecast['ds'] >= '2021-01-01']## Process data Marketing Spentinproduct_future = inproduct_future[['ds', 'yhat']]inproduct_future = inproduct_future.rename(columns={'yhat': 'Inproduct Orders'})## Oragnic## rename for prophet and inproduct prediction df2 = df.rename(columns={'Month': 'ds', 'Prime_orders_ORGANIC_DACH': 'y'})## change the orderdf2 = df2.sort_values('ds', ascending=True)df2 = df2.reset_index()df2.drop(columns=['index'], inplace=True)## set cap and floor cap = df2.max()['y'] * .6floor = df2.min()['y']df2['cap'] = capdf2['floor'] = floor## Months to predictmonths_to_predict = 3## train and test split we only have enough data for two monthstrain = df2.iloc[: len(df2) - int(months_to_predict)]test = df2.iloc[len(df2) - int(months_to_predict):]## Join train = train.merge(df5, on='ds', how="inner")## adjust so we only keep the months we need to predicttrain = train.iloc[:len(df)]test = test.merge(df5, on='ds', how="inner")## Model Organicexecuter = Parallel(n_jobs=-2, backend='loky')tasks = (delayed(fb_model_eval)(train, test, params) for params in all_params)scores = executer(tasks)organic_test = pd.DataFrame(scores).sort_values('RMSE')organic_best = organic_test.iloc[0]print(test)organic_best = organic_best[['params']].values[0]changepoint_prior_scale = list(best.values())[1]seasonality_mode = list(best.values())[0]seasonality_prior_scale = list(best.values())[2]## Foecast## days into the future we want to predicdf3 = df2.merge(df5, on='ds', how='right')forecast_timeframe = 15print(df2.tail())train_model = Prophet(    seasonality_prior_scale=.01,    seasonality_mode='additive',    growth='logistic',    interval_width=0.95,    holidays=holidays,    yearly_seasonality=True)train_model.add_regressor('Acquisition Installs')train_model.add_regressor('Affiliate Installs')train_model.add_regressor('Organic Installs')train_model.fit(df3.iloc[:len(df3) - forecast_timeframe])future = train_model.make_future_dataframe(periods=int(forecast_timeframe), freq='MS')future['cap'] = capfuture['floor'] = floorfuture['Acquisition Installs'] = df3['Acquisition Installs']future['Affiliate Installs'] = df3['Affiliate Installs']future['Organic Installs'] = df3['Organic Installs']forecast2 = train_model.predict(future)## Forecast Plotfrom fbprophet.plot import add_changepoints_to_plotfig = train_model.plot(forecast2)a = add_changepoints_to_plot(fig.gca(), train_model, forecast2)## componentstrain_model.plot_components(forecast2)## only take future values organic_future = forecast2.iloc[len(df2) + 1:]organic_future = organic_future[['ds', 'yhat']]organic_future = organic_future.rename(columns={'yhat': 'Organic Orders'})## Join all dataprime_NB_future = inproduct_future.merge(organic_future, on='ds')## adding additional sheetsimport pandasfrom openpyxl import load_workbookbook = load_workbook("/Users/matthew.bonick/Avira/2021-Forecasting - Documents/prime/prime_2021.xlsx")writer = pandas.ExcelWriter("/Users/matthew.bonick/Avira/2021-Forecasting - Documents/prime/prime_2021.xlsx",                            engine='openpyxl')writer.book = book## ExcelWriter for some reason uses writer.sheets to access the sheet.## If you leave it empty it will not know that sheet Main is already there## and will create a new sheet.writer.sheets = dict((ws.title, ws) for ws in book.worksheets)prime_NB_future.to_excel(writer, "NB DACH")writer.save()## change## test 2